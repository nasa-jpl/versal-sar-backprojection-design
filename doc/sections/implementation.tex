% =============================================================================
\section{Implementation}
% =============================================================================
\label{sec:impl}

% =============================================================================
\subsection{Overview}
% =============================================================================

The design primarily relies on AIE processing, with the ARM Cortex-A72
processor managing AIE input, execution flow, and kernel configuration. This
setup isolates and evaluates the AIE's contribution without involving other
processing resources such as the FPGA or DSP engines. Future efforts may
incorporate these additional resources (see Section \ref{sec:future_work}).

This design builds upon the mathematical formulations presented in "SAR Image
Formation Toolbox for MATLAB" by Gorham et al. \cite{Gorham}. The focus is on
spotlight imaging mode, utilizing the GOTCHA Volumetric SAR dataset discussed
in detail in Section \ref{subsec:dataset}. A parallel processing approach is
employed to accelerate the algorithm from Gorham et al. This leverages the
Versal's architecture by utilizing SIMD instructions, multi-core processing,
and ILP. The current implementation primarily emphasizes SIMD and multi-core
parallelism. Further exploration of ILP optimization is discussed in Section
\ref{sec:future_work}. To validate accuracy, focused output images generated
from both Versal hardware and AIE simulations are compared against image
artifacts produced by the Matlab code provided in Gorham et al.'s appendix.

During development, several custom AIE kernels and graphs were evaluated. The
finalized design includes two custom AIE kernels: the Slowtime Splicer (STS)
and the Image Reconstruction kernel. The design also supports scaling the
number of Image Reconstruction kernels for parallel processing, which can
currently be instantiated 4 or 8 times. Future work aims to further increase
this number (see Section \ref{sec:future_work}).

Both the STS and Image Reconstruction kernels play a crucial role in
accelerating the computationally demanding steps of the Backprojection
algorithm. A high level overview of the two kernels are given below:

\begin{itemize}
    \item \textbf{Slowtime Splicer (STS) Kernel:} A dedicated AIE kernel
        responsible for broadcasting antenna x, y, and z coordinates, range to
        scene center and range compressed data to all Image Reconstruction
        kernels.  
    \item \textbf{Image Reconstruction Kernels:} A dedicated AIE kernel
        responsible for handling the core backprojection processing. They
        calculate the differential range for each pixel in the image (m),
        measuring its relative distance compared to the central pixel. They
        perform cumulative summing and phase correction, leveraging the
        parallel processing capabilities of the AIEs for efficient execution.
\end{itemize}

Additionally, the AIE graph model heavily relies on broadcasting, which is a
AIE graph construct that allows efficiently sending the same data from one
kernel to multiple other kernels in parallel. The kernels and the graph
implementation are talked about in more detail in Sections
\ref{subsec:sts_kern}, \ref{subsec:img_recon_kern}, and \ref{subsec:graph_impl}
below.

% =============================================================================
\subsection{Data Set}
% =============================================================================
\label{subsec:dataset}

The data set used is the "Gotcha Volumetric SAR Data Set, Version
1.0" \cite{GOTCHA}. This data set consists of SAR phase history data collected
at X-band with a 640 MHz bandwidth with full azimuth coverage at 8 different
elevation angles with full polarization. The imaging scene consists of numerous
civilian vehicles and calibration targets. The data is stored in MATLAB binary
format (*.mat files). Each file contains the phase history collected over one
degree of azimuth for a single pass and a single polarization. Loading a file
gives a single MATLAB structure with fields containing the k-space data,
frequencies, X, Y, Z coordinate antenna locations, range to scene center,
azimuth angle (degrees), and elevation angle (degrees).


% =============================================================================
\subsection{Slowtime Splicer (STS) Kernel}
% =============================================================================
\label{subsec:sts_kern}

The STS kernel receives its data from the host processor through 5 GMIO ports
and broadcasts its data via two output ports. Both inputs and outputs are
configured as ping-pong buffers (as opposed to singular buffers or streaming
interfaces). The inputs and outputs for the STS kernel are listed below:

\begin{itemize}
    \item \textbf{x\_ant\_pos\_in (1 float):} The X coordinate of the antenna
    \item \textbf{y\_ant\_pos\_in (1 float):} The Y coordinate of the antenna
    \item \textbf{z\_ant\_pos\_in (1 float):} The Z coordinate of the antenna
    \item \textbf{ref\_range\_in (1 float):} Range to scene center from antenna
    \item \textbf{rc\_in (\textit{RC\_SAMPLES} cfloats):} Range compressed phase
        data
    \item \textbf{slowtime\_out (4 floats):} Antenna X, Y, Z and range to scene
        center data spliced together 
    \item \textbf{rc\_out (\textit{RC\_SAMPLES} cfloats):} Range compressed phase
        data
\end{itemize}

As mentioned in Section \ref{subsec:aie_graphs}, execution of kernels begin
when they receive their specified data samples matching their allocated buffer
size (if using buffers). The list above shows the antenna X, Y, Z and reference
range buffer sizes each being 1 float (4 bytes per float) and the range
compressed phase data buffer size being \textit{RC\_SAMPLES} cfloats (8 bytes
per cfloat), where \textit{RC\_SAMPLES} can variably be set within the
\textit{common.h} header file. Once the input buffers are completely filled,
the kernel will execute. Currently, \textit{RC\_SAMPLES} can only be 64 or 128
cfloats. 128 cfloats is the maximum size due to ping-pong buffer size
limitations. Future work aims to further increase \textit{RC\_SAMPLES} (see
Section \ref{sec:future_work}). Once the STS kernel executes, it performs the
following steps:

\begin{enumerate}
    \item Pop a single float from \textit{x\_ant\_pos\_in} and push it onto the
        \textit{slowtime\_out} buffer
    \item Pop a single float from \textit{y\_ant\_pos\_in} and push it onto the
        \textit{slowtime\_out} buffer
    \item Pop a single float from \textit{z\_ant\_pos\_in} and push it onto the
        \textit{slowtime\_out} buffer
    \item Pop a single float from \textit{ref\_range\_in} and push it onto the
        \textit{slowtime\_out} buffer
    \item The STS kernel now has a full \textit{slowtime\_out} buffer so it
        will automatically release lock on the \textit{slowtime\_out} buffer
        and forward that data out from local memory to the next AIE kernel
        memory in the chain via the AXI4 streaming protocol.
    \item \label{itm:repeat} Pop 16 cfloats from \textit{rc\_in} (SIMD
        operation) and push the vector onto the \textit{rc\_out} buffer
    \item Repeat step \ref{itm:repeat} for a total of \textit{RC\_SAMPLES}/16
        times (since 16 samples are pushed at a time)
    \item The STS kernel now has a full \textit{rc\_out} buffer so it
        will automatically release lock on the \textit{rc\_out} buffer
        and forward that data out from local memory to the next AIE kernel
        memory in the chain via the AXI4 streaming protocol.
\end{enumerate}

After the STS kernel has been executed and its \textit{slowtime\_out} and
\textit{rc\_out} are filled, the output data is sent to all instantiated Image
Reconstruction kernels.

% =============================================================================
\subsection{Image Reconstruction Kernel}
% =============================================================================
\label{subsec:img_recon_kern}

All Image Reconstruction kernels receive its data from the host processor
through 2 GMIO ports and 2 interconnects from the STS kernel. All Image
Reconstruction kernels only have a single GMIO output. Both inputs and outputs
are configured as ping-pong buffers (as opposed to singular buffers or
streaming interfaces). The inputs and outputs for the Image Reconstruction
kernel are listed below:

\begin{itemize}
    \item \textbf{slowtime\_in (4 floats):} Antenna X, Y, Z and range to scene center
    \item \textbf{rc\_in (\textit{RC\_SAMPLES} cfloats):} Range compressed phase data
    \item \textbf{xy\_px\_in (\( \frac{\textit{PULSES} \times
        \textit{RC\_SAMPLES}}{\textit{IMG\_SOLVERS}} \)) cfloats):} X and Y
        pixels of interest for the target scene, where X is the real component
        and Y is the imaginary component 
    \item \textbf{z\_px\_in (\( \frac{\textit{PULSES} \times
        \textit{RC\_SAMPLES}}{\textit{IMG\_SOLVERS}} \)) floats):} Z pixel of
        interest for the target scene 
    \item \textbf{img\_out (\( \frac{\textit{PULSES} \times
        \textit{RC\_SAMPLES}}{\textit{IMG\_SOLVERS}} \)) floats):} The phase
        corrected cumulative sum of a partial segment of the total target scene
        of interest
    \item \textbf{rtp\_rc\_idx\_offset\_in (1 int):} Not currently used
    \item \textbf{rtp\_dump\_img\_in (1 int):} RTP from ARM processor. If set
        to 0, the kernel will continue cumulative sum operations for its
        current execution. If set to 1, the kernel will push the cumulative sum
        to the ARM processor after the current execution is finished.
\end{itemize}

As mentioned in Section \ref{subsec:aie_graphs}, execution of kernels begin
when they receive their specified data samples matching their allocated buffer
size (if using buffers). For the Image Reconstruction kernel, this means the
following condition must be met for it to execute once:

\begin{itemize}
    \item \textit{slowtime\_in} buffer contains 4 floats from STS kernel
    \item \textit{rc\_in} buffer contains \textit{RC\_SAMPLES} cfloats from STS
        kernel
    \item \textit{xy\_px\_in} buffer contains \( \frac{\textit{PULSES} \times
        \textit{RC\_SAMPLES}}{\textit{IMG\_SOLVERS}} \) cfloats from a GMIO
        port
    \item \textit{z\_px\_in} buffer contains \( \frac{\textit{PULSES} \times
        \textit{RC\_SAMPLES}}{\textit{IMG\_SOLVERS}} \) floats from a GMIO port
    \item \textit{rtp\_rc\_idx\_offset\_in} RTP is passed in from the ARM
        processor
    \item \textit{rtp\_dump\_img\_in} RTP is passed in from the ARM processor
\end{itemize}

\noindent Once the Image Reconstruction kernel executes, it performs the following steps:

\begin{enumerate}
    \item Acquire locks on both \textit{rc\_in} and \textit{img\_out} buffers.
        Because \textit{rc\_in} and \textit{img\_out} are both asynchronous
        buffers, the locking and releasing of these buffers must be done
        manually. NOTE: \textit{rc\_in} no longer needs to be asynchronous.
    \item \label{itm:xyz_simd} Fetch 16 cfloats from the \textit{xy\_px\_in}
        buffer and extract the real component 16 floats into its own 16 element
        X vector and extract the imaginary component 16 floats into its own 16
        element Y vector. Also fetch 16 floats from the \textit{z\_px\_in}
        buffer. By storing X, Y, and Z pixels of interest for the target scene
        in their own 16 element vector registers, simultaneous mathematical
        operations can be performed on these 16 element vector registers with a
        single clock cycle (i.e. SIMD).
    \item \label{itm:diff_range} Calculate the differential range from scene
        center. This occurs at 16 elements per clock cycle by using the X, Y,
        and Z pixel vectors from step \ref{itm:xyz_simd}.
    \item \label{itm:diff_range_idx} Divide the differential range vector from
        step \ref{itm:diff_range} by the range resolution to get an index
        vector that can later be used for fetching values from the range
        compressed buffer (used in step \ref{itm:interp}).
    \item \label{itm:ph_corr} Calculate the phase correction vector for the
        image by multiplying the differential range vector from step
        \ref{itm:diff_range} by the phase correction coefficient.
    \item Because the AIE API \textit{sincos\_complex} function only works if
        the domain is between $-\pi$ and $\pi$ (otherwise the output of the
        function will be saturated to -1 or 1), the phase correction vector
        from step \ref{itm:ph_corr} must be scaled up/down by $2\pi$
        accordingly to fall within $-\pi$ and $\pi$.
    \item \label{itm:interp} Because step \ref{itm:diff_range_idx} results in
        fractional numbers, both the closest lower and upper whole number
        indices are derived. These integer indices are used to fetch values
        from the range compressed (\textit{rc\_in}) buffer one at a time
        (vector operations are no longer used at this point since indexing into
        buffers can only be done one element at a time). Linear interpolation
        between the two fetched values of the \textit{rc\_in} buffer provides a
        more accurate representation of the signal at the desired fractional
        index.
    \item \label{itm:px} Take the single interpolated range compressed value
        from step \ref{itm:interp} and multiply it by the phase corrected value
        from step \ref{itm:ph_corr} to get the phase corrected pixel in the image.
    \item \label{itm:img} Cumulatively add the pixel from step \ref{itm:px}
        into an image array stored in the heap of the AIE tile. This Image
        array persists across multiple invocations of the kernel. 
    \item \label{itm:inner_loop} Repeat steps \ref{itm:interp} through
        \ref{itm:img} for a total of 16 times to loop through all of the
        indices within the index vector from step \ref{itm:diff_range_idx}.
    \item Repeat steps \ref{itm:xyz_simd} through \ref{itm:inner_loop} for a
        total of \( \frac{\textit{PULSES} \times
        \textit{RC\_SAMPLES}}{\textit{IMG\_SOLVERS} \times 16 }\) times for all
        of the X, Y and Z pixels of interest within the \textit{xy\_px\_in} and
        \textit{z\_px\_in} buffers.
    \item A single invocation of the Image Reconstruction kernel is completed.
        However, the \textit{img\_out} buffer (intended for transferring the
        final focused image to the ARM processor) remains unwritten at this
        point. This is because the kernel must be invoked \textit{PULSES} times
        to fully focus the image across all pulses. In each invocation, the ARM
        processor provides updated slowtime data and range compressed samples
        (prepared by the STS kernel as described in Section
        \ref{subsec:sts_kern}). During the final pulse, the ARM processor
        signals the Image Reconstruction kernel to write the accumulated
        focused image to the \textit{img\_out} buffer for the last invocation
        by setting the \textit{rtp\_dump\_img\_in} RTP value to 1.
\end{enumerate}

% =============================================================================
\subsection{AIE Graph Implementation}
% =============================================================================
\label{subsec:graph_impl}

% -----------------------------------------------------------------------------
% AIE Graph
% -----------------------------------------------------------------------------
\begin{figure}[hbtp]
  \tiny
  \begin{center}
    \includesvg[width=0.7\textwidth]{figures/aie_5_kern_rc_broadcasting.svg}
  \end{center}
  \caption{AIE graph with 1 Slowtime Splicer and 4 Image Reconstruction 
  kernels.}
  \label{fig:aie_graph}
\end{figure}

% -----------------------------------------------------------------------------






