% =============================================================================
\section{AI Engine Overview}
% =============================================================================
\label{sec:overview}


\subsection{Parallelism and Data Transfer}

% -----------------------------------------------------------------------------
% AIE Array
% -----------------------------------------------------------------------------
\begin{figure}[hbtp]
  \begin{center}
    \includegraphics[width=\textwidth]
    {figures/aie_array.png}
  \end{center}
  \caption{AI Engine Array \cite{AMD_Versal_AM009}}
  \label{fig:aie_array}
\end{figure}
% -----------------------------------------------------------------------------

AI Engines (AIEs) are an array of very-long instruction word (VLIW) processors
with single instruction multiple data (SIMD) vector units that are highly
optimized for compute-intensive applications \cite{AMD_Versal_UG1079}. The AIE
array supports three levels of parallelism:

\begin{itemize}
    \item \textbf{Instruction Level Parallelism (ILP):} Through the VLIW 
        architecture allowing multiple operations to be executed in a single 
        clock cycle.
    \item \textbf{SIMD:} Through vector registers allowing multiple elements
        to be computed in parallel.
    \item \textbf{Multicore:} Through the AIE array, allowing up to 400 AIE
        tiles to execute in parallel.
\end{itemize}

Additionally, there are multiple ways to move data within the AIE tiles, as
well as into and out of them. Figure \ref{fig:aie_array} highlights some of
these data transfer mechanisms. The following list provides a more
comprehensive overview:

\begin{itemize}
    \item \textbf{Local Memory} - Each tile has 32 KB of data memory for
        runtime data.
    \item \textbf{Neighbor Memory Sharing} - A tile can directly access its
        adjacent tiles’ memory via hardware locks, expanding effective local
        storage \cite{AMD_Versal_UG1079}.
    \item \textbf{Cascade Ports} - A dedicated link between adjacent AI Engine
        tiles’ MAC accumulator outputs, used to pass partial sums or
        intermediate results. This path bypasses AXI4 Stream and local memory,
        offering minimal latency for chained computations.
    \item \textbf{AXI4 Stream (Tile-to-Tile)} - General-purpose streaming
        interfaces inside the AI Engine array, typically 32 bits wide per port,
        supporting handshake signals (TVALID, TREADY).
    \item \textbf{Programmable Logic Input/Output (PLIO) Ports} - AXI4 Stream
        connections from the AI Engine array to the FPGA fabric (32, 64, or 128
        bits wide at the interface boundary).
    \item \textbf{Global Memory Input/Output (GMIO) Ports} - Ports to funnel
        data from external DDR (via the NoC) into the AI Engine array, or
        vice-versa. Operates at 64B, 128B, 256B bursts.
    \item \textbf{Memory-Mapped Access (NoC)} - For control or lower-bandwidth
        data transfers, the NoC can directly read/write local memory or
        configure DMA descriptors with AXI memory-mapped transactions.
\end{itemize}

\subsection{AIE Kernels}
\label{subsec:aie_kernels}

An AIE kernel is a C/C++ program which is written using specialized APIs that
target the VLIW vector processor. The AIE kernel code is compiled using the AIE
compiler that is included in the AMD Vitis™ core development kit. The AIE
compiler compiles the kernels to produce an ELF file that is run on the AIE
processors. Up to two kernels can be configured to run on a single AIE tile by
specifying a runtime ratio for the kernel. The AIE compiler will typically
determine while kernels get paired together on an AIE tile based on their
associated runtime configuration.

While most standard C/C++ code can be compiled for the AIE, the code might need
restructuring to take full advantage of the parallelism provided by the
hardware. The power of a single AIE tile is in its ability to execute a
multiply-accumulate (MAC) operation using two vectors, load two vectors for the
next operation, store a vector from the previous operation, and increment a
pointer or execute another scalar operation in each clock cycle. If these
mechanisms are not taken advantage of within the C/C++ code, the overall
performance of the design will be compromised.


\subsection{AIE Graphs}
\label{subsec:aie_graphs}

An AIE program requires a Data Flow Graph (DFG) specification in C++. An
adaptive data flow (ADF) graph is a network composed of one or more AIE kernels
connected by data streams. Figure \ref{fig:aie_graph} shows an example of such
a graph. The ADF graph can interface with the programmable logic (PL), global
memory, and the host processor through specific constructs. In particular, the
\textit{input\_plio} and \textit{output\_plio} (programmable logic input/output)
port objects enable streaming connections to or from the PL, while the
\textit{input\_gmio} and \textit{output\_gmio} (global memory input/output) port
objects provide memory-mapped connections to or from global memory (e.g. DDR).
Additionally, RTP (Runtime Parameter) objects allow setup and control of kernel
parameters during graph execution.

A graph can include multiple kernels as well as input and output ports. AIE
graphs support linking kernels to each other and to these ports, with each link
defined as a connection. Execution begins once the required data samples—those
matching the buffer or stream size expected by the kernels—are available. The
graph then produces output data samples corresponding to the buffer or stream
size expected by each kernel \cite{AMD_Versal_UG1079}.

The interconnections between AIE tiles use an internal AXI4 Stream fabric, but
from the developer’s perspective, these connections can be treated as either
continuous streams or buffer-based windows. When configured in buffer mode
(window-based I/O), the AIE toolflow abstracts the underlying AXI4 Stream
mechanism by requiring the entire buffer to be filled before the kernel can
process or release that data for the next stage.

\subsection{AIE Specification Quick Reference}
\label{subsec:quick_ref}

\begin{itemize}[parsep=1em]
    \item GMIO Ports (DDR $\leftrightarrow$ NoC $\leftrightarrow$ AIE)
        \begin{itemize}[topsep=0em]
            \item 32 GMIO input ports at the graph/system level
            \item 32 GMIO output ports at the graph/system level
            \item Common NoC burst sizes: 64B, 128B, or 256B.
        \end{itemize}

    \item PLIO Ports ($PL \leftrightarrow AIE$)
        \begin{itemize}[topsep=0em]
            \item Configurable bus widths: 32b, 64b, or 128b.
            \item 32 bits per AIE clock (i.e. each 32b take 1 clk cycle for
                AIE)
        \end{itemize}

    \item Clocks
        \begin{itemize}[topsep=0em]
            \item AIE clock: approximately 1.25 GHz (device and speed-grade
                dependent).
            \item NoC clock: approximately 1.0 GHz.
            \item PL clocks: approximately 500 MHz (but can vary widely).
            \item Arm Cortex-A72: approximately 1.35 GHz (also
                device-dependent).
        \end{itemize}

    \item AIE Tile Local Data Memory
        \begin{itemize}[topsep=0em]
            \item 32 KB total per tile for runtime data:
                \begin{itemize}[topsep=0em]
                    \item Ping-pong buffers
                    \item Stack, heap, local variables
                    \item Sync locks, ring buffers, etc.
                \end{itemize}
            \item Realistically, a ping-pong buffer can be up to 16 KB each if
                using double-buffering (i.e. ping-pong buffers).
        \end{itemize}

    \item Neighbor Memory Sharing
        \begin{itemize}[topsep=0em]
            \item Each tile can read/write memory of up to 3 adjacent tiles,
                giving a total potential local + neighbor memory of up to 128
                KB (4× 32 KB) in a 2×2 region.
            \item Requires explicit lock-based
                coordination \cite{AMD_Versal_UG1079}.
        \end{itemize}

    \item Tile Program Memory
        \begin{itemize}[topsep=0em]
            \item 16 KB for application program memory size (separate from the
                32 KB data memory).
        \end{itemize}

    \item AIE AXI4 Stream I/O
        \begin{itemize}[topsep=0em]
            \item Up to 2 input and 2 output streaming ports, each 32 bits
                wide, 1 word/cycle.
            \item Internal FIFOs enable packing 128 bits every 4 cycles,
                depending on external interface needs.
        \end{itemize}
\end{itemize}

These characteristics apply to AIE (V1) devices, not the newer AIE-ML variants,
which differ in memory size, clock domains, and additional ML extensions.


